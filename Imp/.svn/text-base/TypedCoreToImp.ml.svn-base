open Base
open Imp

module TC = TypedCore

let rec translate_value idEnv = function 
  | TC.Var id -> Var (PMap.find id idEnv) 
  | TC.Num n -> Const n 
  | TC.Lam _ -> failwith "wtf do we do with functions?" 

and translate_exp codegen tenv idEnv expectedType = function 
  | TC.ScalarOp(Prim.Select, expectedType, [cond; tVal; fVal]) -> 
      let cond' = translate_value idEnv cond in 
      let tVal' = translate_value idEnv tVal in 
      let fVal' = translate_value idEnv fVal in 
      Select (expectedType, cond', tVal', fVal')
  | TC.ScalarOp (op, t, vs) -> Op(op,t, List.map (translate_value idEnv) vs)   
  | TC.Cast (t, v) -> Cast(t, TC.type_of_value tenv v, translate_value idEnv v)   
  (*| TC.Adverb (adverb, FnVal(fnid, _), args) ->
     let args' = List.map translate_value args in
     let fn = () in  
     translate_adverb codegen tenv adverb fn args' 
    *)   
  (*| TC.ArrayOp (adverb, _, args) ->*) 
      (* when function is unknown we need to switch over all possible function 
         IDs...not yet implemented 
        
      failwith "defunctionalization not yet implemented"
  *)
  | TC.Value v -> translate_value idEnv v 
  
  | TC.Tuple vs -> failwith "tuples not yet implemented"
  | TC.TupleProj (tuple, idx) -> failwith "tuple projection not yet implemented"
  | _ -> failwith "[typed core -> imp] typed core exp not yet implemented "
and translate_stmt tenv idEnv codegen = function 
  | TC.Set([id],exp) ->  
      let t = PMap.find id tenv in
      let id' = 
        if PMap.mem id idEnv then PMap.find id idEnv 
        else codegen#fresh_id t
      in  
      let exp' = translate_exp codegen tenv idEnv t exp in
      codegen#emit [set (Var id') exp'];
      PMap.add id id' idEnv 
      
  | _ -> failwith "typedcore -> imp: stmt not yet supported"      
      
(* 

input_ids : ID.t array;
           input_types : ty array;
           output_ids : ID.t array; 
           output_types : ty array;
           (* all IDs which aren't inputs or outputs are locals *)     
           local_ids : ID.t array;   
           local_types : ty array;         
           body : stmt array;
           tenv :(ID.t,DynType.t) PMap.t; 
           shared : (ID.t, int list) PMap.t
*) 

(*
   body: block;
    
    input_ids : ID.t list; 
    input_types : DynType.t list; 

    output_ids : ID.t list; 
    output_types : DynType.t list; 
    
    tenv : (ID.t, DynType.t) PMap.t; 
*)
and translate fn =
  let codegen  = new ImpCodegen.imp_codegen in
  let tenv = fn.TC.tenv in
  let freshInputIds = 
    List.map codegen#fresh_input_id  fn.TC.input_types in 
  let freshOutputIds = 
    List.map codegen#fresh_output_id  fn.TC.output_types in 
  let idEnv =  PMap.combine 
    (PMap.of_list (List.combine fn.TC.input_ids freshInputIds)) 
    (PMap.of_list (List.combine fn.TC.output_ids freshOutputIds)) in 
  let _ = List.fold_left 
    (fun idEnv stmt -> translate_stmt tenv idEnv codegen stmt) 
    idEnv
    fn.TC.body in 
  codegen#finalize  
  