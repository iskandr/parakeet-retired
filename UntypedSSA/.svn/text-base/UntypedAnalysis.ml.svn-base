open Base
open UntypedSSA

(* generic structure of a recursive analysis, fill in the details by 
   inheriting from base_analysis
*)

class ['a] base_analysis = object
    method stmt (env : 'a) (stmt : UntypedSSA.stmt) = env    
    method exp (env : 'a) (exp : UntypedSSA.exp)  = env
    method value (env : 'a) (v : UntypedSSA.value) = env
end


let rec eval_block logic env code = 
  let stmt_folder (env,changed) stmt = 
    let env', changed' = eval_stmt logic env  stmt in 
    env', changed || changed'
  in  
  List.fold_left stmt_folder (env,false) code
      
and eval_stmt logic env node = 
  let env', changed = match node.stmt with
  | Ignore rhs
  | Set (_, rhs) -> 
    let rhsEnv, rhsChanged = eval_exp logic env rhs in 
    logic#stmt rhsEnv node.stmt, rhsChanged  
  | If (cond, tBlock, fBlock, _) ->
    let condEnv, condChanged = eval_value logic env cond in  
    let trueEnv, tChanged = eval_block logic condEnv tBlock in 
    let falseEnv, fChanged = eval_block logic trueEnv fBlock in
    logic#stmt falseEnv node.stmt, (condChanged || tChanged || fChanged)  
  | SetIdx (_, indices, rhs)->  
    let indicesEnv, indicesChanged = eval_value_list logic env indices in 
    let rhsEnv, rhsChanged = eval_value logic indicesEnv rhs in 
    logic#stmt rhsEnv node.stmt, (indicesChanged || rhsChanged)  
  in 
  env', changed || (env != env')      
and eval_exp logic env expNode = 
  let env', changed = match expNode.exp with 
  | Value v -> eval_value logic env v 
  | TupleProj (v1,v2) -> eval_value_list logic env [v1;v2] 
  | ArrayIndex(fn,args)
  | App (fn,args) -> eval_value_list logic env (fn::args) 
  | Arr vs 
  | Tuple vs -> eval_value_list logic env vs
  in
  let env'' = logic#exp env' expNode.exp in 
  env'', changed || (env != env'')  
and eval_value logic env v = 
  let env', changed = match v with  
  | Lam fundef -> eval_block logic env fundef.body  
  | _ -> env, false
  in  
  let env'' = logic#value env' v in 
  env'', changed || (env != env'') 
and eval_value_list logic env vs =
  let val_folder (env,changed) v = 
    let env', changed' = eval_value logic env v in 
    env', changed || changed'   
  in List.fold_left val_folder (env,false) vs

(* COMMENTED OUT UNTIL WE HAVE LOOPS *) 
 (* if the value lattice is of finite height, this iteration should converge
      but put a maxiters of 100 just in case 
  *) 
(*
and iterate ?(niters = 1) env block = 
    let env', changed = eval_block env block in 
    if changed || niters > 100 then iterate ~niters:(niters + 1) env' block 
    else env, niters > 1 
*)
