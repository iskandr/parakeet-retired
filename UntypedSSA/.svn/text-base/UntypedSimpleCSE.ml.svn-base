
open Base
open UntypedSSA 

(* expressions without side effects *) 
let is_safe_exp = function 
  | App(Prim _, _) 
  | Arr _ 
  | Tuple _ 
  | TupleProj _ 
  | Value _ -> true
  (* assume function calls unsafe by default-- might be too strong*)
  | _ -> false 

let rec eval_block env = function 
  | [] -> [], false
  | stmtNode::rest -> 
      let stmt', env', stmtChanged = eval_stmt env stmtNode.stmt in
      let rest', restChanged = eval_block env' rest in 
      {stmtNode with stmt = stmt'}::rest', stmtChanged || restChanged 
  
and eval_stmt env stmt =
  match stmt with 
  | Set (id, expNode) when is_safe_exp expNode.exp -> 
    if PMap.mem expNode.exp env then ( 
      let rhsVal = PMap.find expNode.exp env  in
      Printf.printf "[CSE] replacing %s with %s \n"
        (UntypedSSA.exp_to_str expNode)
        (UntypedSSA.value_to_str rhsVal);
      let rhs' = {expNode with exp = Value rhsVal } in
      Set(id, rhs'), env, true
    ) 
    else
      let exp', changed = eval_exp env expNode.exp in
      let rhs' = {expNode with exp = exp' } in    
      let env' = PMap.add exp' (Var id) env in 
      Set (id, rhs'), env', changed
  (* if not a safe expression  *) 
  | Set _ ->  stmt, env, false
  | Ignore expNode -> 
    if PMap.mem expNode.exp env then 
      let rhs' = 
        {expNode with exp = Value (PMap.find expNode.exp env)} in 
      (Ignore rhs'), env, true 
    else 
      let exp', changed = eval_exp env expNode.exp in
      let rhs' = {expNode with exp = exp' } in    
      Ignore rhs', env, changed   
    
  | If (cond, tBlock, fBlock, gate) -> 
    (* for now don't try to eliminate expressions common between branches, 
       and ignore the subexpressions computed in each branch since 
       those values won't be unconditionally available 
    *)
    let tBlock', tChanged = eval_block env tBlock in
    let fBlock', fChanged = eval_block env fBlock in 
    If(cond, tBlock', fBlock', gate), env, tChanged || fChanged
and eval_exp env = function 
  | Value v -> 
      let v', changed = eval_value env v in 
      Value v', changed  
  | Arr vs -> 
      let vs', changed = eval_value_list env vs in 
      Arr vs', changed
  | Tuple vs -> 
      let vs', changed = eval_value_list env vs in 
      Tuple vs', changed
  | App(fn, args) -> 
      let fn', fnChanged = eval_value env fn in 
      let args', argsChanged = eval_value_list env args in 
      App(fn', args'), fnChanged || argsChanged   
  | exp -> exp, false   
and eval_value env = function 
  | Lam fundef -> 
    let body',changed = eval_block env fundef.body in 
    Lam {fundef with body = body'}, changed
  | v -> v, false 
and eval_value_list env = function 
  | [] -> [], false
  | v::vs -> 
      let v', changed = eval_value env v in 
      let rest, restChanged = eval_value_list env vs in 
      v'::rest, changed || restChanged 
let cse block = eval_block PMap.empty block  
  
      