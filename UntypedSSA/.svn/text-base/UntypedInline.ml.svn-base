open Base
open UntypedSSA 

let get_constant_function constEnv = function 
  | Lam fundef -> Some fundef 
  | Var id when PMap.mem id constEnv -> 
      (match PMap.find id constEnv with
      | UntypedFindConstants.Const (Lam fundef) -> Some fundef
      | _ -> None
      )  
  | _ -> None  

let rename = ()


let do_inline fundef argVals = 
  let bodyIds, _ = UntypedFindGenSet.block_gens fundef.body in 
  let allIds = fundef.input_ids @ (PSet.to_list bodyIds) in 
  let nvars = List.length allIds in  
  let freshIds = ID.gen_fresh_list nvars in
  let replaceMap = PMap.of_list (List.combine allIds freshIds) in 
  let body' = UntypedReplace.replace_block replaceMap fundef.body in
  let newInputIds = 
    List.map (fun id -> PMap.find id replaceMap) fundef.input_ids in
  let newOutputIds = 
    List.map (fun id -> PMap.find id replaceMap) fundef.output_ids in
  let set_arg id arg = { 
      stmt=Set(id, {exp=Value arg; exp_src=None}); 
      stmt_src=None;
  } in 
  let argAssignments = List.map2 set_arg newInputIds argVals in   
  (*let set_result oldId newId = { 
      stmt = Set(oldId, {exp=Value (Var newId); exp_src=None}); stmt_src=None
  } in 
  let resultAssignments = List.map2 set_result newOutputIds resultIds in
  *)  
  argAssignments @ body', newOutputIds  
  
  
let rec inline_block constEnv block = 
  let allStmts, allChanged = 
    List.split (List.map (inline_stmt constEnv) block) in 
  let anyChanged = List.fold_left (||) false allChanged in 
  let flatStmts = List.concat allStmts in 
  flatStmts, anyChanged
    
and inline_stmt constEnv node =
  match node.stmt with  
  | Set (id, rhs) -> 
    let rhs', changed, extraStmts = inline_exp constEnv rhs in 
    extraStmts @ [{node with stmt=Set(id, rhs')}], changed
  | Ignore rhs ->
    let rhs', changed, extraStmts = inline_exp constEnv rhs in 
    extraStmts @ [{node with stmt = Ignore rhs'}], changed  
  | If (condVal, tBlock, fBlock, ifGate) ->
    let condVal', condChanged = inline_value constEnv condVal in 
    let tBlock', tChanged = inline_block constEnv tBlock in 
    let fBlock', fChanged = inline_block constEnv fBlock in 
    let changed = condChanged || tChanged || fChanged in 
    [{node with stmt = If (condVal', tBlock', fBlock', ifGate)}], changed
  | SetIdx(id, indices, rhsVal) -> 
    let indices', indicesChanged = inline_value_list constEnv indices in 
    let rhsVal', rhsChanged = inline_value constEnv rhsVal in
    let changed = indicesChanged || rhsChanged  in  
    [{node with stmt = SetIdx(id, indices', rhsVal')}], changed  
and inline_exp constEnv node =
  match node.exp with 
  | App (fn, args) -> 
      let fn', fnChanged = inline_value constEnv fn in 
      let args', argsChanged = inline_value_list constEnv args in
      let noInline = 
        {node with exp = App(fn', args')}, (fnChanged || argsChanged), []
      in 
      
      (match get_constant_function constEnv fn' with 
        | None -> noInline 
        | Some fundef -> 
          (* make sure arity lines up *)
          if List.length fundef.input_ids <> List.length args then noInline
          else 
          let inlineCode, retIds = do_inline fundef args' in
          if List.length retIds <> 1 then 
            failwith "multiple return values not handled"
          else 
            let retVal = Value (Var (List.hd retIds)) in 
            {node with exp = retVal}, true, inlineCode
      )   
  | ArrayIndex (arr, indices) ->
      let arr', arrChanged = inline_value constEnv arr in 
      let indices', indicesChanged = inline_value_list constEnv indices in
      let node' = {node with exp = ArrayIndex(arr', indices')} in 
      let changed = arrChanged || indicesChanged in 
      node', changed, []
  | Arr vs ->   
      let vs', changed = inline_value_list constEnv vs in
      {node with exp = Arr vs'}, changed, []
  | Tuple vs ->
      let vs', changed = inline_value_list constEnv vs in 
      {node with exp = Tuple vs'}, changed, []    
  | Value v ->
      let v', changed = inline_value constEnv v in 
      {node with exp = Value v'}, changed, []
       
  | TupleProj(v1, v2) -> 
      let v1', changed1 = inline_value constEnv v1 in
      let v2', changed2 = inline_value constEnv v2 in
      {node with exp = TupleProj (v1', v2')}, changed1 || changed2, [] 
 
and inline_value constEnv = function  
 | Lam fundef  -> 
     let body', changed = inline_block constEnv fundef.body in 
     Lam {fundef with body=body'}, changed 
 | const -> const, false 
and inline_value_list constEnv  = function 
  | [] -> [], false
  | v::vs ->
      let v', currChanged = inline_value constEnv v in 
      let vs', restChanged = inline_value_list constEnv vs in 
      v'::vs', currChanged || restChanged     
  

let run_inliner code =
  let constEnv = UntypedFindConstants.find_constants code in
  let code', changed = inline_block constEnv code in 
  Printf.printf "%s\n" (UntypedSSA.block_to_str code');
  code', changed   

  