open Base
open UntypedSSA

(* generic structure of a recursive analysis, fill in the details by 
   inheriting from base_analysis
???
*)

class ['a] base_transformation = object
    method stmt_set (env : 'a) stmtNode id rhsExp = env
    
          | Set (id, rhs) ->  
    let rhs', changed = eval_exp defEnv constEnv rhs in
    {stmtNode with stmt = Set (id, rhs') }, changed    
    method exp (env : 'a) (exp : UntypedSSA.exp) = env
    method value (env : 'a) (v : UntypedSSA.value) = env 
end
   
let rec eval_block logic env code = 
  List.fold_left (eval_stmt logic) env code
      
and eval_stmt logic env node = 
  match node.stmt with
  | Ignore rhs
  | Set (_, rhs) -> logic#stmt (eval_exp logic env rhs) node.stmt 
  | If (cond, tBlock, fBlock, _) ->
      let condEnv = eval_value logic env cond in  
      let trueEnv = eval_block logic condEnv tBlock in 
      let falseEnv= eval_block logic trueEnv fBlock in
      logic#stmt falseEnv node.stmt 
  | SetIdx (_, indices, rhs)->  
      let indicesEnv = eval_value_list logic env indices in 
      let rhsEnv = eval_value logic indicesEnv rhs in 
      logic#stmt rhsEnv node.stmt 
      
and eval_exp logic env expNode = 
  match expNode.exp with 
  | Value v -> logic#exp (eval_value logic env v) expNode.exp 
  | TupleProj (v1,v2) -> 
      logic#exp (eval_value_list logic env [v1;v2]) expNode.exp  
  | ArrayIndex(fn,args)
  | App (fn,args) -> 
    logic#exp (eval_value_list logic env (fn::args)) expNode.exp 
and eval_value logic env v = 
  match v with  
  | Lam fundef -> logic#value (eval_block logic env fundef.body) v
  | Arr vs 
  | Tuple vs -> logic#value (eval_value_list logic env vs) v
  | _ -> logic#value env v 
and eval_value_list logic env vs = 
  List.fold_left (eval_value logic) env vs
  
 

 