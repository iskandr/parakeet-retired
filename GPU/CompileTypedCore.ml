open Base
open Cuda
open GpuVal
open LibPQ
open Printf
open TypedCore

(* send workflow values to the GPU or simply return if they're already there *)
let workflow_value_to_gpu memState = function
  | Var id -> MemoryState.get_gpu memState id
  | Const n -> GpuVal.mk_scalar n
  | FnVal _ -> failwith "function ain't goin to no gpu"

exception InvalidGpuArgs

(* currently only works for nested arrays *)
let sizeof ty shape =
  DynType.sizeof (DynType.elt_type ty) * Shape.nelts shape  
  
(* every statement of workflow needs an associated launcher, 
   which is generated by this function.
*)
let compile_adverb tempId op resultType kernelName args =
  fun  modulePtr memState ->
    printf "In statment launcher, putting args on GPU \n%!";
    let gpuVals = List.map (workflow_value_to_gpu memState) args in
    let shapes = List.map GpuVal.get_shape gpuVals in
    let types = List.map GpuVal.get_type gpuVals in
    match op with
    | Prim.Map ->
       let maxShape, maxType =
         (match Shape.max_shape_list shapes, DynType.fold_type_list types with
          | None, _
          | _, None -> raise InvalidGpuArgs
          | Some maxShape, Some maxType -> maxShape, maxType
         )
       in
       let outputSize = sizeof maxType maxShape in
       printf "Making output vector... \n%!";
       let outputVal = GpuVal.mk_gpu_vec maxType maxShape outputSize in
       let args = Array.of_list (gpuVals @ [outputVal]) in
       let outputElts = Shape.nelts maxShape in
        
       let threads_x = 256 in
       (* need to compute size of result *)
       let gridwidth = (outputElts / threads_x) + 1 in
      Printf.printf "tx: %d gw: %d num elts: %d\n" threads_x gridwidth outputElts;
       let launchParams = {
          cuda_module = modulePtr;
          fn_name = kernelName;
            (* need to put output array at beginning here *)
          args = args;
          threads_x = threads_x;
          threads_y = 1;
          threads_z = 1;
          gridwidth = gridwidth;
          gridheight = 1;
      }
      in
      printf "Launching PTX... \n%!";
      printf "launchParams.cuda_module: %Lx\n%!" launchParams.cuda_module;
      printf "fn_name: %s\n%!" launchParams.fn_name;
      launch_ptx launchParams;
      printf "Adding tempID to memstate PTX... \n%!";
      MemoryState.add_gpu memState tempId outputVal;

    | _ -> failwith "[compile_workflow] operator not yet supported"

(* every unique combination of array operator and scalar function
   has a kernel generated for it, which must be named
*)
let kernel_name adverb fnid argTypes =
  sprintf "%s_%s_%s"
    (Prim.adverb_to_str adverb)
    (FnId.to_str fnid)
    (String.replace_chars 
       (function '<' | '>' -> "_" | c -> String.of_char c)  
       (String.concat "_" $ List.map DynType.to_str argTypes))

(* accumulate a ptx module and launching function as you compile
   each statement of the body. At the end of the body, call nvidia's 
   JIT on the text of the ptx_module. Return a CuModulePtr.t and 
   final launcher for the whole body. 
*) 
let compile_body body tenv functions  =
    let rec aux kernels revLaunchers = function
    | (Return [Var returnId])::_ ->
			 (* At the end of a workflow: 
			      (i)    Linearize a kernel map into the string represenations of
                   each kernel 

            (ii)   Compile the string of PTX generated from the kernels, yielding
                   a module pointer. 

            (iii)  Return the module pointer, launchers, the id of the 
                   variable to return 
       *)
        let ptxModule = {
          Ptx.kernels = kernels; 
          Ptx.compute_capability = Ptx.SM_13
        } in 
        let ptxStr = Ptx.ptx_module_to_str ptxModule in
        print_string ptxStr;
        let modulePtr = compile_module ptxStr in
        Printf.printf
            "\n\n [CompileWorkflow] Created CUDA module at address: %Lx \n\n%!"
            modulePtr;
        let launchers = List.rev revLaunchers in
        modulePtr, launchers, returnId

	  (* Every statement of the workflow is transformed into 
		   a kernel, which is added to the module. A launcher is then
		   generated for this kernel, which is added to the list of launchers.
		*)
    | (Let(retId, Adverb(adverb, fnVal, args)) as stmt)::rest ->
        printf "[CompileWorkflow] Compiling statement %s\n%!" $
            TypedCore.stmt_to_str stmt; 
        let argTypes = List.map (TypedCore.type_of_value tenv) args in
        let retType = PMap.find retId tenv in
        let fnId =TypedCore.get_fn_id fnVal in   
        let kname = kernel_name adverb fnId argTypes  in
        let fn = Hashtbl.find functions fnId  in
        let kernel = match adverb with 
          | Prim.Map -> CompileMapKernel.compile fn argTypes retType  
          | _ -> failwith "[CompileWorkflow] Adverb not yet supported"
        in 
        (* check to make sure the PTX we generate is valid, die if it's not *) 
        let kernelErrors = PtxValidate.validate_kernel kernel in 
        if kernelErrors <> [] then 
        (  printf "Problem with kernel:\n%s\n Errors:\n%s\n%!"
             (Ptx.kernel_to_str kernel kname)  
             (PtxValidate.kernel_errors_to_str kernel kernelErrors);
          failwith "Encountered PTX errors!" 
        );  
        (* if the PTX was OK, add the kernel to the growing list of all *)
        (* kernels used in this workflow *) 
        let kernels' = String.Map.add kname kernel kernels  in
        (* make a launcher for the statement associated with this kernel, *)
        (* which will put all required data on the gpu and get the kernel*)
        (* running. *)
        let stmtLauncher = compile_adverb retId adverb retType kname args in
        aux kernels' (stmtLauncher::revLaunchers) rest
        
    | (_ as stmt)::_ -> failwith $ 
        ("Not yet supported: "^ (TypedCore.stmt_to_str stmt))
    | [] -> failwith "Malformed workflow, never saw return statement"
    in
    aux String.Map.empty [] body 

(* A function launcher:
     - abstracts converts host_val arguments to gpu_vals
     - launches a sequence of kernels
     - returns a host_val .
*) 
type fn_launcher = {
  launch :  HostVal.host_val list -> HostVal.host_val;
  destroy: unit -> unit
}

let compile fn fns =
  (*let fn = PMap.find fnid program in*) 
  let modulePtr, launchers, returnId = 
    compile_body fn.body fn.tenv fns in 
    (* Turn the list of launchers into a single entry function,
       of type host_val ->  host_val, which runs the entire
       sequence of launchers, and then returns their result.
    *)
  let launchAll : HostVal.host_val list -> HostVal.host_val =
    fun hostVals ->
      Printf.printf
      "[launcher] Launching kernel with %d args\n%!" (List.length hostVals);
      (* total number of variables used in the workflow *) 
      let nvars = PMap.num_keys fn.tenv in 
      let memState = MemoryState.create nvars in 
      let argIds = fn.input_ids in  
      (* pair each input value with its argument ID and add 
         it to the MemoryState on the host
      *) 

      List.iter2 (MemoryState.add_host memState) argIds hostVals;
      List.iter (fun launcher -> launcher modulePtr memState) launchers;
      printf "Finished all kernel launches in workflow, bringing result back to host\n%!";
      let hostVal = MemoryState.get_host memState returnId in 
      MemoryState.free_all_gpu memState; 
      hostVal 

  in { launch = launchAll;
       destroy = (fun () -> LibPQ.destroy_module modulePtr)
     }
