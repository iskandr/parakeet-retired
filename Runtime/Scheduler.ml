(* pp: -parser o pa_macro.cmo *)

(* TODO: Get rid of GPU/Host distinction and replace with arbitrary number*)
(* of backends/memspaces *) 

(* the cost model function expect arguments to be described by triplets  *)
(* of their type, shape, and a boolean indicating whether that argument  *)
(* is on the gpu.                                                        *)

type value = ArrayId.t Value.t 
type values = value list 

let describe_arg v = typeof v, shapeof v, is_on_gpu v

let describe_args vs = List.map describe_arg vs


let map fn ?(axes=[0]) ~fixed args = 
  match CostModel.map_cost fn (describe_args fixed) (describe_args args) with 
  | CostModel.GPU, _ ->
      let gpuClosureVals = List.map DataManager.get_gpu fixed in 
      let gpuInputVals = List.map DataManager.get_gpu argVals in 
      DataManager.enter_data_scope (); 
      let gpuResults = 
        GpuEval.map 
          ~payload: fn
          ~closureArgs: gpuClosureVals 
          ~args: gpuInputVals
      in
      let results = List.map DataManager.add_gpu gpuResults in 
      DataManager.exit_data_scope results;
      results

  | CostModel.CPU, _ -> 
      IFDEF DEBUG THEN Printf.printf "[Eval] running map on CPU\n" ENDIF;
      InterpBackend.map fn fixed args  

let reduce fn ?(axes=[0]) ~fixed args =
(match 
        CostModel.reduce_cost 
            ~fnTable: P.fnTable 
            ~init: initFundef
            ~initClosureArgs: (describe_args initClosureArgs)
            ~fn: reduceFundef
            ~closureArgs: (describe_args reduceClosureArgs)
            ~initArgs: (describe_args initArgVals)
            ~args: (describe_args argVals) 
      with 
        | CostModel.GPU, _ -> 
           
          let gpuResults = 
            GpuEval.reduce
              ~init: initFundef
              ~initClosureArgs: (List.map get_gpu initClosureArgs)
              ~payload: reduceFundef 
              ~payloadClosureArgs: (List.map get_gpu reduceClosureArgs)
              ~initArgs: (List.map get_gpu initArgVals)
              ~args: (List.map get_gpu argVals) 
          in 
          List.map add_gpu gpuResults
          

        | CostModel.CPU, _ -> failwith "CPU reduction not implemented"
      )

and eval_array_op (op : Prim.array_op) (argVals : value list) : value list =
  
(* push a scope to clean up any non-escaping temporaries generated by      *)
(* array operators                                                         *)
    DataManager.enter_data_scope (); 
    let results = match op, argVals with
    | Prim.Index, [array; idx] ->
      (* always run on GPU *)
      let gpuArr = get_gpu array in 
      if Type.is_scalar (typeof idx) then (
        if Type.nest_depth (typeof array) = 1 then 
          let gpuVec = GpuVal.get_gpu_vec gpuArr in 
          let n = GpuVal.get_elt gpuVec (Value.to_int idx) in 
          [Value.Scalar n]
      (* TODO: What about pulling out whole rows from the GPU? *)
        else failwith "[Eval] Slicing a single row not yet supported" 
      )
      else 
        let gpuIdx = get_gpu idx in 
        let gpuResult = GpuEval.index gpuArr gpuIdx in 
        [add_gpu gpuResult] 
    | Prim.Where, [binVec] ->
      (* always run on GPU *)
      let gpuVec = get_gpu binVec in 
      let gpuResult = GpuEval.where gpuVec in 
      [add_gpu gpuResult] 
        
    | Prim.DimSize, [array; idx] ->
      (* always run on Host *)
      let s = DataManager.get_shape array in
      let i = Value.to_int idx in
      let result = Value.of_int (Shape.get s i) in 
      IFDEF DEBUG THEN 
        Printf.printf "DimSize(%s, %s): %s\n"
          (Value.to_str array)
          (Value.to_str idx)
          (Value.to_str result);
      ENDIF; 
      [result] 
    | Prim.Til, [n] ->
      (* always run on Host *)
       let count = ParNum.to_int (DataManager.get_scalar n) in
       let arr = Array.init count (fun i -> Value.of_int i) in 
       [Value.Array arr] 
    | Prim.Til, others -> 
      (* always run on host *)
      failwith $ Printf.sprintf 
        "Where's my scalar? I ordered a scalar: %s (host: %s)"
        (String.concat ", " (List.map Value.to_str others))
        (String.concat ", " 
          (List.map HostVal.to_str 
            (List.map (DataManager.get_host P.memState) others))) 

     | op, args -> 
        failwith $ Printf.sprintf "CPU operator not implemented: %s for args %s"
          (Prim.array_op_to_str op)
          (String.concat ", " (List.map Value.to_str args)) 
     in 
     DataManager.exit_data_scope results; 
     results 